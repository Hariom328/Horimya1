const {
    APIMessage,
    Structures,
    MessageAttachment,
    MessageEmbed
} = require("discord.js");
const mergeOptions = require("merge-options");
const {
    defaultOptions
} = require("./options");
const fetch = require(`node-fetch`)
class Message extends Structures.get("Message") {
    async mentionReply(content, options) {

        let mentionRepliedUser = typeof ((options || content || {}).allowedMentions || {}).repliedUser === "undefined" ? true : ((options || content).allowedMentions).repliedUser;

        const apiMessage = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this.channel, content, options).resolveData();
        Object.assign(apiMessage.data, {
            message_reference: {
                message_id: this.id
            }
        });

        if (!apiMessage.data.allowed_mentions || Object.keys(apiMessage.data.allowed_mentions).length === 0) {
            apiMessage.data.allowed_mentions = {
                parse: ["users", "roles", "everyone"]
            }
        }

        if (typeof apiMessage.data.allowed_mentions.replied_user === "undefined") {
            Object.assign(apiMessage.data.allowed_mentions, {
                replied_user: mentionRepliedUser
            });
        }

        if (Array.isArray(apiMessage.data.content)) {
            return Promise.all(apiMessage.split().map(x => {
                x.data.allowed_mentions = apiMessage.data.allowed_mentions;
                return x;
            }).map(this.lineReply.bind(this)));
        }

        const {
            data,
            files
        } = await apiMessage.resolveFiles();
        return this.client.api.channels[this.channel.id].messages
            .post({
                data,
                files
            })
            .then(d => this.client.actions.MessageCreate.handle(d).message);
    }

    async noMentionReply(content, options) {



        const apiMessage = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this.channel, content, options).resolveData();
        Object.assign(apiMessage.data, {
            message_reference: {
                message_id: this.id
            }
        });

        if (!apiMessage.data.allowed_mentions || Object.keys(apiMessage.data.allowed_mentions).length === 0) {
            apiMessage.data.allowed_mentions = {
                parse: ["users", "roles", "everyone"]
            }
        }

        Object.assign(apiMessage.data.allowed_mentions, {
            replied_user: false
        });

        if (Array.isArray(apiMessage.data.content)) {
            return Promise.all(apiMessage.split().map(x => {
                x.data.allowed_mentions = apiMessage.data.allowed_mentions;
                return x;
            }).map(this.lineReply.bind(this)));
        }

        const {
            data,
            files
        } = await apiMessage.resolveFiles();
        return this.client.api.channels[this.channel.id].messages
            .post({
                data,
                files
            })
            .then(d => this.client.actions.MessageCreate.handle(d).message);
    }
}

Structures.extend("Message", () => Message);
const emojiString = ":regional_indicator_";

module.exports = {
    /**
     * 
     * @param {String} text The message you want to convert from text to emoji text.
     * @returns {string} Returns the emojified text, note: you have to use await for this to happen!
     * @example let emojified = await discordify.emojify('YOUR MESSAGE HERE!');
     */
    emojify: async function (text) {
        if (!text) throw new Error("No message provided!");
        let char = text.split("");
        let RegxChar = RegExp(/[a-z]/i);
        let end = [];

        await char.forEach(ch => {
            if (RegxChar.test(ch)) {
                end.push(`${emojiString}${ch}: `);
            } else if (ch === "!") {
                end.push('❗️');
            } else if (ch === "?") {
                end.push('❓');
            } else {
                end.push(ch + ' ');
            }
        });
        return end.map(ch => ch).join("");
    },

    /**
     * 
     * @param {String} text The message you want to convert from text to owo text.
     * @returns {string} Returns the owofied text.
     * @example let owofied = await discordify.owofy('YOUR MESSAGE HERE!');
     */
    owoify: function (text) {
        if (!text) throw new Error("No message provided!");
        return text
            .replace(/[lr]/g, "w")
            .replace(/[LR]/g, "W")
            .replace(/n([aeiou])/g, "ny$1")
            .replace(/N([aeiou])/g, "Ny$1")
            .replace(/N([AEIOU])/g, "Ny$1")
            .replace(/ove/g, "uv");
    }
};
module.exports = class nidhish {
    /**
     * @param {import('./options').defaultOptions} options
     */
    constructor(options) {
        /**
         * @type {defaultOptions}
         */
        this.options = mergeOptions(defaultOptions, options);
    }

    /**
     * @param {Message} message
     */
    async Cat(message) {
        let body = await fetch(`https://some-random-api.ml/img/cat`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "cat.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }


    /**
     * @param {Message} message
     */
    async Redpanda(message) {
        let body = await fetch(`https://some-random-api.ml/img/red_panda`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "redpanda.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Bird(message) {
        let body = await fetch(`https://some-random-api.ml/img/birb`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "bird.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Koala(message) {
        let body = await fetch(`https://some-random-api.ml/img/koala`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "koala.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }
    async Fox(message) {
        let body = await fetch(`https://some-random-api.ml/img/fox`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "fox.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Panda(message) {
        let body = await fetch(`https://some-random-api.ml/img/panda`).then((res) =>
            res.json()
        );
        let url = body.link;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "panda.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }
    async Dog(message) {
        let body = await fetch(`https://dog.ceo/api/breeds/image/random`).then((res) =>
            res.json()
        );
        let url = body.message;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "dog.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Alpaca(message) {
        let body = await fetch(`https://apis.duncte123.me/animal/alpaca`).then((res) =>
            res.json()
        );
        let url = body.data.file;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "alpaca.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Llama(message) {
        let body = await fetch(`https://apis.duncte123.me/animal/llama`).then((res) =>
            res.json()
        );
        let url = body.data.file;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "llama.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

    /**
     * @param {Message} message
     */
    async Lizard(message) {
        let body = await fetch(`https://apis.duncte123.me/animal/lizard`).then((res) =>
            res.json()
        );
        let url = body.data.file;

        let image = new MessageAttachment(url);
        if (this.options.type === "embed") {
            let embed = new MessageEmbed()
                .setColor("RANDOM")
                .setImage(image.attachment)
                .setTimestamp();
            return message.channel.send(embed);
        } else if (this.options.type === "message") {
            let photo = new MessageAttachment(url, "lizard.png");
            return message.channel.send("", {
                files: [photo],
            });
        } else if (this.options.type === "url") {
            return console.log(url);
        }
    }

}

module.exports.tictactoe = require("./data/class/TicTacToe");
module.exports.chatbot = require('./data/functions/chatbot')
module.exports.getadvice = require('./data/functions/getadvice')
module.exports.getfact = require('./data/functions/getfact')
module.exports.getmeme = require('./data/functions/getmeme')
module.exports.password = require('./data/functions/password')
module.exports.SnakeGame = require('./data/class/snakegame')
module.exports.connectfour = require('./data/class/connectfour')
module.exports.guessthenumber = require('./data/class/guessthenumber')
module.exports.getinsult = require('./data/functions/getinsult')
module.exports.embedpages = require('./data/class/embedpages')
module.exports.getjoke = require('./data/functions/getjoke')
module.exports.animalimage = require(`./data/functions/animaimage`)
module.exports.gethpussy = require(`./data/functions/nsfw/gethpussy`)
module.exports.gethboobs = require(`./data/functions/nsfw/gethboobs`)
module.exports.getRandomHGif = require(`./data/functions/nsfw/getRandomHentaiGif`)
module.exports.getherok = require(`./data/functions/nsfw/getherok`)
module.exports.gethfeetg = require(`./data/functions/nsfw/gethfeetgif`)
module.exports.getneko = require(`./data/functions/sfw/getneko`)
module.exports.getnekogif = require(`./data/functions/sfw/getnekogif`)
module.exports.gethlesbian = require(`./data/functions/nsfw/gethlesbian`)
module.exports.gethbjgif = require(`./data/functions/nsfw/gethbjgif`)
module.exports.gethbj = require(`./data/functions/nsfw/gethbj`)
module.exports.gethtrap = require(`./data/functions/nsfw/gethtrap`)
module.exports.getwallpaper = require(`./data/functions/sfw/getwallpaper`)
module.exports.getfoxgirl = require(`./data/functions/sfw/getfoxgirl`)
module.exports.generateAnimeQuote = require(`./data/functions/getanimequote`)
module.exports.generateQuote = require(`./data/functions/getquote`)